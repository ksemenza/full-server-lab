"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var os = require("os");
var prettier = require("prettier");
var common_1 = require("../common");
var utils_1 = require("../../utils");
function format(code, options) {
    if (options === void 0) { options = {}; }
    try {
        return prettier.format(code, __assign({}, options, { parser: 'typescript' }));
    }
    catch (e) {
        console.log("There is a syntax error in generated code, unformatted code printed, error: " + JSON.stringify(e));
        return code;
    }
}
exports.format = format;
function generate(args) {
    // TODO: Maybe move this to source helper
    var inputTypesMap = args.types
        .filter(function (type) { return type.type.isInput; })
        .reduce(function (inputTypes, type) {
        var _a;
        return __assign({}, inputTypes, (_a = {}, _a["" + type.name] = type, _a));
    }, {});
    // TODO: Type this
    var typeToInputTypeAssociation = args.types
        .filter(function (type) {
        return type.type.isObject &&
            type.fields.filter(function (field) { return field.arguments.filter(function (arg) { return arg.type.isInput; }).length > 0; }).length > 0;
    })
        .reduce(function (types, type) {
        var _a;
        return __assign({}, types, (_a = {}, _a["" + type.name] = [].concat.apply([], type.fields.map(function (field) {
            return field.arguments
                .filter(function (arg) { return arg.type.isInput; })
                .map(function (arg) { return arg.type.name; });
        })), _a));
    }, {});
    var interfacesMap = common_1.createInterfacesMap(args.interfaces);
    var unionsMap = common_1.createUnionsMap(args.unions);
    var hasPolymorphicObjects = Object.keys(interfacesMap).length > 0 || Object.keys(unionsMap).length > 0;
    return "  " + renderHeader(args, { hasPolymorphicObjects: hasPolymorphicObjects }) + "\n\n  " + common_1.renderEnums(args) + "\n\n  " + renderNamespaces(args, interfacesMap, unionsMap, typeToInputTypeAssociation, inputTypesMap) + "\n\n  " + renderResolvers(args) + "\n\n  " + (args.iResolversAugmentationEnabled
        ? renderGraphqlToolsModuleAugmentationIResolvers()
        : '') + "\n\n  ";
}
exports.generate = generate;
/**
 * This renders a TypeScript module augmentation against graphql-tools
 * IResolvers type. Apollo Server uses that type to type its resolvers.
 * The problem with that type is that it is very loose compared to
 * graphqlgen including being an index type. The index type in particular
 * breaks compatibility with the resolvers generated by graphqlgen. We
 * fix this by augmenting the IResolvers type.
 *
 * References:
 *
 *  - https://www.typescriptlang.org/docs/handbook/declaration-merging.html
 *  - https://github.com/prisma/graphqlgen/issues/15
 */
var renderGraphqlToolsModuleAugmentationIResolvers = function () {
    // Use ts-ignore otherwise tests will throw an error about no such
    // module being found. Further, if a user for some reason is not using
    // Apollo Server, then this augmentation doesn't matter anyways, and
    // should not throw an exception for them either.
    return "\n    // @ts-ignore\n    declare module \"graphql-tools\" {\n      interface IResolvers extends Resolvers {}\n    }\n  ";
};
function renderHeader(args, _a) {
    var _b = (_a === void 0 ? {} : _a).hasPolymorphicObjects, hasPolymorphicObjects = _b === void 0 ? false : _b;
    var imports = hasPolymorphicObjects
        ? ['GraphQLResolveInfo', 'GraphQLIsTypeOfFn']
        : ['GraphQLResolveInfo'];
    return "\n// Code generated by github.com/prisma/graphqlgen, DO NOT EDIT.\n\nimport { " + imports.join(', ') + " } from 'graphql'\n" + renderImports(args) + "\n  ";
}
function renderImports(args) {
    var _a;
    var modelsToImport = Object.keys(args.modelMap)
        .filter(function (modelName) {
        var modelDef = args.modelMap[modelName].definition;
        return !(modelDef.kind === 'TypeAliasDefinition' &&
            modelDef.isEnum);
    })
        .map(function (modelName) { return args.modelMap[modelName]; });
    var modelsByImportPaths = common_1.groupModelsNameByImportPath(modelsToImport);
    if (args.context) {
        var importsFromContextPath = modelsByImportPaths[args.context.contextPath] || [];
        return importsToString(Object.assign({}, modelsByImportPaths, (_a = {},
            _a[args.context.contextPath] = importsFromContextPath.concat(common_1.getContextName(args.context)),
            _a)));
    }
    return "" + importsToString(modelsByImportPaths) + os.EOL + "type " + common_1.getContextName(args.context) + " = any";
}
function importsToString(modelsByImportPaths) {
    return Object.keys(modelsByImportPaths)
        .map(function (importPath) {
        return "import { " + modelsByImportPaths[importPath].join(', ') + " } from '" + importPath + "'";
    })
        .join(os.EOL);
}
function renderNamespaces(args, interfacesMap, unionsMap, typeToInputTypeAssociation, inputTypesMap) {
    return "    " + renderObjectNamespaces(args, interfacesMap, unionsMap, typeToInputTypeAssociation, inputTypesMap) + "\n\n    " + renderInterfaceNamespaces(args, interfacesMap, unionsMap) + "\n\n    " + renderUnionNamespaces(args) + "\n  ";
}
function renderObjectNamespaces(args, interfacesMap, unionsMap, typeToInputTypeAssociation, inputTypesMap) {
    return args.types
        .filter(function (type) { return type.type.isObject; })
        .map(function (type) {
        return renderNamespace(type, interfacesMap, unionsMap, typeToInputTypeAssociation, inputTypesMap, args);
    })
        .join(os.EOL);
}
function renderInterfaceNamespaces(args, interfacesMap, unionsMap) {
    return args.interfaces
        .map(function (type) { return renderInterfaceNamespace(type, interfacesMap, unionsMap, args); })
        .join(os.EOL);
}
function renderUnionNamespaces(args) {
    return args.unions.map(function (type) { return renderUnionNamespace(type, args); }).join(os.EOL);
}
function renderInterfaceNamespace(graphQLTypeObject, interfacesMap, unionsMap, args) {
    return "    export namespace " + graphQLTypeObject.name + "Resolvers {\n      " + renderInputArgInterfaces(graphQLTypeObject, args.modelMap, interfacesMap, unionsMap) + "\n\n      export interface Type {\n        __resolveType: " + exports.renderTypeResolveTypeResolver(graphQLTypeObject, args) + "\n      }\n    }\n  ";
}
exports.renderTypeResolveTypeResolver = function (abstractType, args) {
    var modelNames = [];
    var gqlObjectNameTypes = [];
    var gqlObjects = abstractType.kind === 'interface'
        ? abstractType.implementors
        : abstractType.types;
    for (var _i = 0, gqlObjects_1 = gqlObjects; _i < gqlObjects_1.length; _i++) {
        var gqlObj = gqlObjects_1[_i];
        modelNames.push(common_1.getModelName(gqlObj, args.modelMap));
        gqlObjectNameTypes.push(renderStringConstant(gqlObj.name));
    }
    return "\n  (\n    value: " + common_1.union(modelNames) + ",\n    context: " + common_1.getContextName(args.context) + ",\n    info: GraphQLResolveInfo\n  ) => " + common_1.resolverReturnType(common_1.union(gqlObjectNameTypes)) + "\n  ";
};
var renderStringConstant = function (x) { return "\"" + x + "\""; };
function renderUnionNamespace(graphQLTypeObject, args) {
    return "    export namespace " + graphQLTypeObject.name + "Resolvers {\n      export interface Type {\n        __resolveType?: " + exports.renderTypeResolveTypeResolver(graphQLTypeObject, args) + "\n      }\n    }\n  ";
}
function renderNamespace(graphQLTypeObject, interfacesMap, unionsMap, typeToInputTypeAssociation, inputTypesMap, args) {
    return "    export namespace " + graphQLTypeObject.name + "Resolvers {\n\n    " + (args.defaultResolversEnabled
        ? common_1.renderDefaultResolvers(graphQLTypeObject, args, 'defaultResolvers')
        : '') + "\n\n    " + renderInputTypeInterfaces(graphQLTypeObject, args.modelMap, interfacesMap, unionsMap, typeToInputTypeAssociation, inputTypesMap) + "\n\n    " + renderInputArgInterfaces(graphQLTypeObject, args.modelMap, interfacesMap, unionsMap) + "\n\n    " + renderResolverFunctionInterfaces(graphQLTypeObject, args.modelMap, interfacesMap, unionsMap, args.context) + "\n\n    " + renderResolverTypeInterface(graphQLTypeObject, args.modelMap, interfacesMap, unionsMap, args.context) + "\n\n    " + '' + "\n  }\n  ";
}
function renderIsTypeOfFunctionInterface(type, modelMap, interfacesMap, unionsMap, context) {
    var possibleTypes = [];
    // TODO Refactor once type is a proper discriminated union
    if (!type.type.isInterface) {
        type = type;
        if (type.implements) {
            possibleTypes = type.implements.reduce(function (obj, interfaceName) {
                return obj.concat(interfacesMap[interfaceName]);
            }, []);
        }
    }
    for (var unionName in unionsMap) {
        if (unionsMap[unionName].find(function (unionType) { return unionType.name === type.name; })) {
            possibleTypes = unionsMap[unionName];
        }
    }
    if (possibleTypes.length === 0) {
        return '';
    }
    return "    __isTypeOf?: GraphQLIsTypeOfFn<" + possibleTypes
        .map(function (possibleType) { return common_1.getModelName(possibleType, modelMap); })
        .join(' | ') + ", " + common_1.getContextName(context) + ">;";
}
function renderInputTypeInterfaces(type, modelMap, interfacesMap, unionsMap, typeToInputTypeAssociation, inputTypesMap) {
    if (!typeToInputTypeAssociation[type.name]) {
        return "";
    }
    return common_1.getDistinctInputTypes(type, typeToInputTypeAssociation, inputTypesMap)
        .map(function (typeAssociation) {
        return "export interface " + inputTypesMap[typeAssociation].name + " {\n      " + inputTypesMap[typeAssociation].fields.map(function (field) {
            return common_1.printFieldLikeType(field, modelMap, interfacesMap, unionsMap);
        }) + "\n    }";
    })
        .join(os.EOL);
}
function renderInputArgInterfaces(type, modelMap, interfacesMap, unionsMap) {
    return type.fields
        .map(function (field) {
        return renderInputArgInterface(field, modelMap, interfacesMap, unionsMap);
    })
        .join(os.EOL);
}
function renderInputArgInterface(field, modelMap, interfacesMap, unionsMap) {
    if (field.arguments.length === 0) {
        return '';
    }
    return "\n  export interface Args" + utils_1.upperFirst(field.name) + " {\n    " + field.arguments
        .map(function (arg) {
        return common_1.printFieldLikeType(arg, modelMap, interfacesMap, unionsMap);
    })
        .join(os.EOL) + "\n  }\n  ";
}
function renderResolverFunctionInterfaces(type, modelMap, interfacesMap, unionsMap, context) {
    return type.fields
        .map(function (field) {
        return "export type " + utils_1.upperFirst(field.name) + "Resolver = " + renderTypeResolver(field, type, modelMap, interfacesMap, unionsMap, context);
    })
        .join(os.EOL);
}
function renderResolverTypeInterface(type, modelMap, interfacesMap, unionsMap, context, interfaceName) {
    if (interfaceName === void 0) { interfaceName = 'Type'; }
    return "\n  export interface " + interfaceName + " {\n    " + type.fields
        .map(function (field) {
        return field.name + ": " + renderTypeResolver(field, type, modelMap, interfacesMap, unionsMap, context);
    })
        .join(os.EOL) + "\n      " + renderIsTypeOfFunctionInterface(type, modelMap, interfacesMap, unionsMap, context) + "\n  }\n  ";
}
var renderTypeResolver = function (field, type, modelMap, interfacesMap, unionsMap, context) {
    var parent;
    if (type.type.isInterface) {
        var implementingTypes = interfacesMap[type.name];
        parent = implementingTypes
            .map(function (implType) { return common_1.getModelName(implType, modelMap, 'undefined'); })
            .join(' | ');
    }
    else {
        parent = common_1.getModelName(type.type, modelMap, 'undefined');
    }
    var params = "\n  (\n    parent: " + parent + ",\n    args: " + (field.arguments.length > 0 ? "Args" + utils_1.upperFirst(field.name) : '{}') + ",\n    ctx: " + common_1.getContextName(context) + ",\n    info: GraphQLResolveInfo,\n  )\n  ";
    var returnType = common_1.printFieldLikeType(field, modelMap, interfacesMap, unionsMap, { isReturn: true });
    if (type.name === 'Subscription') {
        return "\n    {\n      subscribe: " + params + " => " + common_1.resolverReturnType("AsyncIterator<" + returnType + ">") + "\n      resolve?: " + params + " => " + common_1.resolverReturnType(returnType) + "\n    }\n    ";
    }
    var resolveFunc = params + " => " + common_1.resolverReturnType(returnType);
    var DelegatedParentResolver = "\n    {\n      fragment: string\n      resolve: " + resolveFunc + "\n    }\n  ";
    var resolver = common_1.union(["(" + resolveFunc + ")", DelegatedParentResolver]);
    return resolver;
};
function renderResolvers(args) {
    return "export interface Resolvers {\n  " + args.types
        .filter(function (obj) { return obj.type.isObject; })
        .map(function (type) { return type.name + ": " + type.name + "Resolvers.Type"; }).concat(args.interfaces.map(function (type) { return type.name + "?: " + type.name + "Resolvers.Type"; }), args.unions.map(function (type) { return type.name + "?: " + type.name + "Resolvers.Type"; })).join(os.EOL) + "\n}\n  ";
}
//# sourceMappingURL=generator.js.map